🛡️ DWP Backend Integrated Development Rules (v1.6 - Final Merged)

0. 목적 (Goal)
DWP Backend는 DWP Frontend(Host/Remote) 및 Aura-Platform(Python/FastAPI)과 통합되는 멀티 모듈 MSA이다.
본 Rules는 “프론트/게이트웨이/서비스 간 계약(Contract)”을 코드로 고정하여 시스템 전체의 통합 안정성과 추적 가능성(Traceability)을 보장한다.
작업시 커밋 푸시는 내 명령없이는 절대 수행하지 않는다

1. 아키텍처 원칙 & 모듈별 역할
- Multi-Module MSA: Spring Boot 3.4.x 기반 Gradle 멀티 모듈 구조를 엄격히 준수한다.
- Single Ownership Principle:
  - dwp-core: 공통 기반. DTO, ApiResponse<T>, 전역 예외 처리, HeaderConstants, Redis 공통 설정, 공통 유틸
  - dwp-gateway: 유일한 외부 진입점. 라우팅, 헤더 전파(Propagation), CORS, SSE 스트리밍 중계, 공통 로깅(API Call History) 전담
  - dwp-auth-server: 인증/인가 + Admin 영역(IAM/RBAC/Monitoring/Code/Policy) 단일 소유
  - dwp-main-service: 상태 관리. AgentTask, HITL 세션, 장기 실행 작업(Lifecycle) 관리 단일 소유
  - services/*: 도메인 서비스. AI 에이전트가 호출하는 개별 비즈니스 도구(Tool) API 제공

✅ Admin 기능 개발 원칙
- IAM/RBAC/Monitoring/Code/AuthPolicy/IDP 등 “공통 운영 기능”은 dwp-auth-server에 집중한다.
- 서비스 도메인(ERP 등) 기능은 services/* 로 분리하는 것을 기본 원칙으로 하되,
  현재 단계에서는 안정화 후 분리를 허용한다.

2. 통합 계약 및 헤더 표준 (Header Contract)
모든 요청은 Gateway(8080)를 거치며, 다음 헤더는 다운스트림 및 FeignClient 통신 시 누락 없이 전파되어야 한다.

2.1 필수 보안 헤더 (Required)
- Authorization: Bearer <JWT>
  - HS256 기반 서명 검증
  - tenant_id 클레임 필수
  - 표준 시간 클레임(iat/exp) 기반 만료 처리 권장
- X-Tenant-ID: 멀티테넌시 식별자 (DB 조회 시 tenant filter 강제)
- X-User-ID: 사용자 식별자

2.2 추적 및 컨텍스트 헤더 (Trace/Context)
- X-Agent-ID: Aura 에이전트 세션/클라이언트 식별자
- X-DWP-Source: 요청 출처 (FRONTEND, AURA, INTERNAL, BATCH)
- X-DWP-Caller-Type: 호출자 유형 (USER, AGENT, SYSTEM)

3. 에이전틱 AI & SSE 통신 규격 (Agentic AI & SSE)
3.1 SSE 기본 규칙
- Streaming: MediaType.TEXT_EVENT_STREAM_VALUE 사용
- Gateway Timeout: SSE 스트림이 끊기지 않도록 300초 이상 설정
- Buffering 방지: 중간 프록시/게이트웨이에서 버퍼링되지 않도록 설정
- Method: POST 기반 SSE 응답 공식 지원

3.2 SSE 재연결 및 상태 복구 (Resilience)
- Event ID: 모든 SSE 이벤트에 단조 증가 eventId/sequence 포함 권장
- Last-Event-ID: 재연결 시 resume 가능하면 지원, 불가하면 재시작 정책 문서화

3.3 이벤트 타입 계약 (Aura UI v1.0)
- 표준 이벤트: thought, plan_step, tool_execution, hitl, content, timeline_step_update, plan_step_update
- 종료 선언: data: [DONE]\n\n

4. HITL (Human-In-The-Loop) & 승인 프로세스
- State 소유권: dwp-main-service가 승인 대기 상태를 단일 소유
- 승인 전파: Redis Pub/Sub으로 Aura-Platform에 신호 발행
- 보안: 요청자 권한 + 테넌트 일치 재검증

5. AgentTask 및 비동기 작업 관리
- 영속화: 모든 에이전트 요청은 AgentTask로 DB 기록
- 진행도: planSteps(JSON), progress(0~100), 상태(REQUESTED/IN_PROGRESS/COMPLETED/FAILED)
- 비동기 처리: 10초 이상 작업은 비동기 처리 + taskId 즉시 반환

6. 데이터 및 기술 표준
- Stack: Java 17, Spring Boot 3.4.x, Spring Cloud Gateway, OpenFeign, Redis 7, PostgreSQL 15
- Response: 모든 API 응답은 dwp-core의 ApiResponse<T>로 통일
- JWT: Python ↔ Java HS256 호환성 유지 (클레임/검증 규칙 문서로 고정)

7. 코드 품질 및 추적성 (Traceability)
- Swagger(springdoc-openapi)로 API 명세 자동 생성
- Logging:
  - traceId + X-Agent-ID 포함 권장
  - Gateway/Downstream Correlation 전략 유지
- Header Injection:
  - FeignClient RequestInterceptor로 표준 헤더 자동 주입/전파

8. 보안 및 멀티테넌시
- Data Isolation: 모든 DB 조회는 tenant_id 필터 강제
- RBAC Scope: 권한 밖 접근(타 테넌트 포함) 차단

────────────────────────────────────────────────────────
🧩 Admin CRUD Engineering Pattern (Hard Standard)
────────────────────────────────────────────────────────
✅ Admin CRUD API는 “운영 유지보수”를 위해 반드시 표준 분리 구조를 따른다.
- Controller는 mapping + guard만
- Query/Command 분리로 서비스 비대화 방지
- 하드코딩 제거(CodeResolver/CodeUsage 기반)

[패키지 표준]
controller/admin/
service/admin/<feature>/
  - <Feature>QueryService
  - <Feature>CommandService
  - <Feature>Validator
dto/admin/<feature>/
repository/
entity/

[API 통일]
GET    /api/admin/<feature>              # list
GET    /api/admin/<feature>/{id}         # detail
POST   /api/admin/<feature>              # create
PATCH  /api/admin/<feature>/{id}         # update
DELETE /api/admin/<feature>/{id}         # delete

[권한]
- /api/admin/** : JWT 필수 + ADMIN enforcement
- sidebar 숨김과 무관하게 BE enforcement가 최종 보안 기준

[코드 하드코딩 금지]
- "MENU","UI_COMPONENT","USER","ADMIN"... 직접 비교 금지
- CodeResolver.require/validate + CodeUsage 범위 내 코드만 허용

[감사로그]
- 모든 CRUD는 com_audit_logs 기록 기본값
- before/after json 가능한 범위 기록 권장

────────────────────────────────────────────────────────
🧾 Persistence Rule: JPA + QueryDSL Only (Native Query Prohibited)
────────────────────────────────────────────────────────
- 기본 원칙: 모든 DB 접근은 Spring Data JPA + QueryDSL로 구현한다.
- ❌ @Query(nativeQuery = true) 사용 금지
- ❌ EntityManager.createNativeQuery / JDBC Template 기반 SQL 직접 실행 금지
- ❌ MyBatis / XML Mapper 도입 금지

- ✅ 허용:
  - Spring Data JPA (JPQL) + QueryDSL(JPAQueryFactory)
  - 복잡한 검색/필터/정렬/페이징은 RepositoryCustom + QueryDSL로 구현
  - 성능 이슈가 있으면:
    1) 인덱스(Flyway) 우선
    2) DTO Projection(QueryDSL) 우선
    3) fetch join / batch size / pagination 최적화
  - 그래도 불가피한 경우에만 “예외 승인 절차”를 따른다.

- ✅ Native Query 예외 승인(매우 제한적):
  - 반드시 ADR 또는 docs/에 사유/SQL/대안 검토/성능 근거(Explain/Analyze)를 남기고
  - tech lead 리뷰 승인 후에만 허용


────────────────────────────────────────────────────────
🧹 Maintainability & Refactor Gate (운영 유지보수 규칙)
────────────────────────────────────────────────────────
- Class Size Limit (Hard)
  - Controller: 250라인 초과 금지
  - Service: 350라인 초과 금지
  - Repository/Entity: 300라인 초과 금지
  - 초과 시 반드시 책임 단위로 분리한다.

- Layered Responsibility (Mandatory)
  - Controller: Request/Response 매핑 + 인증/권한 Guard 호출만 담당
  - Service: 유즈케이스 오케스트레이션만 담당
  - 세부 로직은 아래로 분리:
    - *QueryService: 조회 전용(검색/페이징/정렬)
    - *CommandService: 생성/수정/삭제 전용
    - *Validator: 입력값/비즈니스 룰 검증
    - *Mapper: Entity ↔ DTO 변환 전용

- Transaction Rule
  - 조회: @Transactional(readOnly = true)
  - 생성/수정/삭제: @Transactional 명시
  - Controller에서 @Transactional 금지

- Contract Safety
  - API 응답 DTO 변경은 반드시 버전/호환성 고려
  - 프론트 계약 영향이 있으면 docs/에 API Spec 업데이트 필수

- Testing Gate (Minimum)
  - Query/Command 각각 핵심 테스트 1개 이상 필수
  - Role/Permission 계산, CodeUsage 매핑 로직은 단위 테스트 유지

- Refactor Rule
  - 리팩토링 PR에서는 기능 변경 금지(동작/응답 동일 유지)
  - 예외: 명백한 버그/성능 문제 해결은 허용

[Cursor Action Guideline]
본 규칙을 바탕으로 코드를 생성할 때, 특히 Gateway 설정 / Header 전파 / SSE 스트리밍 반환부에서
규격 위반이 없는지 최우선으로 검증하십시오.
